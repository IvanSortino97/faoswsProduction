# Fill imputation for Non-Livestock Commodities

**Author: Josh Browning, Michael C. J. Kao**

**Description:**

This module loads the imputed values generated by the "Impute Non-livestock"
module and the update the values in the dataset before saving back to the
database.

**Inputs:**

* Production domain
* Imputed `.rds` object
* Yield formula table

**Flag Changes:**

| Procedure | Observation Status Flag | Method Flag |
| --- | --- | --- |
| Compute/Balance | `<Flag Aggregation>` | i |
| Imputation | I | e |

---
Load the libraries

```{r }
suppressMessages({
    library(faosws)
    library(faoswsUtil)
    library(faoswsProduction)
    library(faoswsProcessing)
    library(faoswsEnsure)
    library(magrittr)
    library(dplyr)
})
```

set up for the test environment and parameters

```{r }
R_SWS_SHARE_PATH = Sys.getenv("R_SWS_SHARE_PATH")
modelLoadingPath = paste0(R_SWS_SHARE_PATH, "/kao/production/imputation_fit/")
```

This return FALSE if on the Statistical Working System

```{r }
if(CheckDebug()){

    library(faoswsModules)
    SETTINGS = ReadSettings("sws.yml")

    ## If you're not on the system, your settings will overwrite any others
    R_SWS_SHARE_PATH = SETTINGS[["share"]]

    ## Define where your certificates are stored
    SetClientFiles(SETTINGS[["certdir"]])

    ## Get session information from SWS. Token must be obtained from web interface
    GetTestEnvironment(baseUrl = SETTINGS[["server"]],
                       token = SETTINGS[["token"]])
    modelLoadingPath = SETTINGS[["load_imputation_path"]]
}


selectedKey = swsContext.datasets[[1]]
```

Get the full imputation Datakey

```{r }
completeImputationKey = getCompleteImputationKey()
```

Subset the item of the complete key to the selected items. We use the
complete key to subset as the selection may not include the full list of
year/country/elements

```{r }
selectedImputationItems = selectImputationItem(selectedKey, completeImputationKey)
```

Test whether the selected keys are in the complete key, if not in the
completeImputationKey, then it will be returned as a message that the item
should probably be added in.

```{r }
nonImputationItemCodes = nonImputationItems(selectedKey, completeImputationKey)
```

Start the imputation, looping through each item since the model are fitted
for each item separately.

```{r }
for(i in seq(selectedImputationItems)){
    ## Select the item and the associate formula/elements
    currentItem = selectedImputationItems[i]
    currentFormula = getYieldFormula(currentItem)
    currentElements =
        currentFormula %>%
        select(input, productivity, output) %>%
        unlist(x = ., use.names = FALSE)

    processingParams =
        productionProcessingParameters(
            datasetConfig = GetDatasetConfig("agriculture", "aproduction"),
            productionCode = currentFormula$output,
            areaHarvestedCode = currentFormula$input,
            yieldCode = currentFormula$productivity)

    ## Give warning if the imputed data set does not exist
    if(!imputationExist(modelLoadingPath = modelLoadingPath,
                        item = currentItem))
        stop("Imputation does not exist for item '", currentItem,
             "'. Please run imputation model first.")

    ## TODO (Michael): This creates the name of the imputation
    ##                 object. Probably need a function to standardise
    ##                 and sync this with the create_imputed_dataset
    ##                 module.
    modelName = createImputationObjectName(item = currentItem)

    ## Modify the selected key
    subKey = selectedKey
    subKey@dimensions$measuredItemCPC@keys = currentItem
    subKey@dimensions$measuredElement@keys = currentElements

    print(paste0("Filling missing values for item: ",
                 currentItem, " (",  i, " out of ",
                 length(selectedImputationItems),")"))

    ## Load the fitted values
    imputedValues =
        readRDS(file = paste0(modelLoadingPath, modelName)) %>%
        preProcessing(data = .) %>%
        filter(flagObservationStatus == "I" & flagMethod %in% c("i", "e")) %>%
        setkeyv(x = ., col = c("geographicAreaM49", "measuredItemCPC",
                               "timePointYears", "measuredElement"))

    ## Load the selected data from the data base
    currentValues =
        GetData(subKey) %>%
        fillRecord(data = .) %>%
        preProcessing(data = .) %>%
        ensureProductionInputs(data = .,
                               processingParam = processingParameters,
                               formulaParameters = formulaParameters) %>%
        setkeyv(x = , col = c("geographicAreaM49", "measuredItemCPC",
                              "timePointYears", "measuredElement"))

    ## NOTE (Michael): Need to think about what should be
    ##                 updated. Should we over-write all the data with
    ##                 specific set of flags, or only values that are
    ##                 missing?

    saveResult =
        {
            ## NOTE (Michael): Only impute production if the item is
            ##                 not a primary commodity.
            if(isPrimary(currentItem)){
                return(currentValues)
            } else {
                return(currentValues[measuredElement %in%
                                     currentFormula[, output], ])
            }
        } %>%
        ## Inner join with the imputed data
        ##
        ## TODO (Michael): Need to add a check here if the
        ##                 imputedValues dataset is smaller than the
        ##                 selected values. This is an indication that
        ##                 the imputation does not perform on all
        ##                 data.
        .[imputedValues, ] %>%
        ## Subset only flags that can be over-written
        ##
        ## i - calculated based on identity.
        ## t - Carry-forward estimate.
        ## e - Estimate automatically generated by a statistical algorithm.
        ## n - Value not collected or estimated, but can be assumed to be
        ##     negligible.
        ## u - Value not known.
        filter(flagMethod %in% c("i", "t", "e", "n", "u")) %>%
        ## Assign the imputed value to the current dataset
        mutate(Value = i.Value,
               flagObservationStatus = i.flagObservationStatus,
               flagMethod = i.flagMethod) %>%
        ## Remove imputation column
        select(.data = ., select = -starts_with("i.")) %>%
        ## Module testing
        ##
        ## NOTE (Michael): The check production balanced might fail because the
        ##                 data may have been updated since the production
        ##                 imputation module was performed.
        ensureProductionOutputs(data = .,
                                processingParameters = processingParameters,
                                formulaParameters = formulaParameters) %>%
        postProcessing(data = .) %>%
        ## Save data back
        SaveData(domain = "agriculture", dataset = "aproduction", data = .)

}
```

Return messages

```{r }
yearOutOfImputationRange =
    setdiff(selectedKey@dimensions$timePointYears@keys, imputationYears)

yearWarningMessage =
    ifelse(length(yearOutOfImputationRange) > 0,
           paste0("\n\nThe following selected years were not imputed as they ",
                  "are out of range (1999 - current year): \n",
                  paste0(yearOutOfImputationRange, collapse = ", "), "\n"),
           "")


commodityWarningMessage =
    ifelse(length(nonImputationItemCodes) > 0,
           paste0("\n\n The following selected commodities were not ",
                  "imputed as they are not included in the current list:\n",
                  paste0(nonImputationItemCodes, collapse = ", "), "\n"),
           "")

finalMessage =
    paste0("Imputation module executed successfully\n",
           yearWarningMessage,
           commodityWarningMessage)

message(finalMessage)
```

